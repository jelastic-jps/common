actions:
  checkClustering:
    script: |
      var secondEnvName, resp, config= {}, isLockEnv = false, isSecondExecuted = false;
      resp = api.env.control.ExecCmdByGroup({
        envName: "${env.name}",
        session: session,
        nodeGroup: "cp",
        commandList: [{"command": "cat /root/clustering"}],
        userName: "root"
      });
      if (resp.result != 0) return resp;
      text = resp.responses[0].out.split("\n");
      for (var i = 0, n = text.length; i < n; i++) {
        tmp = text[i].split("=");
        config[tmp[0]] = tmp[1];
      }
      if (config.cluster) config.cluster = String(config.cluster) != "false";
      secondEnvName = ("${env.name}" == config.envName1) ? config.envName2 : config.envName1;
      resp = api.env.control.ExecCmdByGroup({
          envName: "${env.name}",
          session: session,
          nodeGroup: "cp",
          commandList: [{"command": "[[ -f \"/root/${this.app_id}.lock\" ]] && echo true || echo false"}],
          userName: "root"
        });
      if (resp.result != 0) return resp;
      isLockEnv = !!(resp.responses[0].out == "true");
      resp = api.env.control.ExecCmdByGroup({
        envName: secondEnvName,
        session: session,
        nodeGroup: "cp",
        commandList: [{"command": "[[ -f \"/root/${this.app_id}.executed\" ]] && echo true || echo false"}],
        userName: "root"
      });
      if (resp.result != 0) return resp;
      isSecondExecuted = !!(resp.responses[0].out == "true");
      return {
        result: 0,
        onAfterReturn: {
          setGlobals: {
            secondEnvName: secondEnvName,
            isSecondEnv: !!isLockEnv,
            isSecondExecuted: isSecondExecuted,
            cluster: config.cluster
          }
        }
      }
      return { result: 0, secondEnvName: secondEnvName }
  markExecutedEnvFile:
    createLockFile:
      app_id: ${this.app_id}
      envName: ${env.envName}
      extension: executed

  removeExecutedEnvFile:
    script: |
      return api.env.control.ExecCmdByGroup({
        envName: "${env.envName}",
        session: session,
        nodeGroup: "cp",
        commandList: [{"command": "rm -rf /root/${this.app_id}.${this.extension:executed}"}],
        userName: "root"
      });
  createLockFile:
    script: |
      return api.env.control.ExecCmdByGroup({
        envName: "${this.envName}",
        session: session,
        nodeGroup: "cp",
        commandList: [{"command": "touch /root/${this.app_id}.${this.extension:lock}"}],
        userName: "root"
      });
  executeAction:
    script: |
      var envAppid, nodeType, resp, params = {};
      resp = api.env.control.GetEnvInfo("${this.envName}", session);
      if (resp.result != 0) return resp;
      for (var i = 0, n = resp.nodes.length; i < n; i++) {
        if (resp.nodes[i].nodeGroup == "${globals.nodeGroup}") {
          nodeType = resp.nodes[i].nodeType;
        }
      }
      envApid = resp.env.appid;
      resp = api.dev.scripting.Eval("appstore", session, "GetApps", {
        targetAppid: envApid,
        search: {
          appstore: 1,
          nodeGroup: "cp",
          nodeType: nodeType,
          jpsType: "update"
        }
      });
      if (resp.result != 0) return resp;
      if (resp.response && resp.response.apps) {
        for (var i = 0, n = resp.response.apps.length; i < n; i++) {
          if (resp.response.apps[i].app_id == "${this.app_id}") {
            uniqueName = resp.response.apps[i].uniqueName;
            break;
          }
        }
      }
      params = "${this.parameters:}" || {};
      if ("${this.action:}" == "delete") {
        return api.marketplace.jps.Uninstall(appid, session, uniqueName);
      }
      return api.marketplace.jps.ExecuteAppAction({
        appid: appid,
        session: session,
        appUniqueName: uniqueName,
        action: "${this.action}",
        params: {
            customDomains: "${settings.customDomains}"
        }
      });
